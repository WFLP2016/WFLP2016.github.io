<!DOCTYPE html
      PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
      "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US" style="display:none" xml:lang="en-US">
<head>
<title>WFLP 2016 Talk Schedule and Pre-Proceedings</title>
<script>window['ec:pageId']='4828311993964363776'</script>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<script>if(self != top) {top.location = self.location} else {document.documentElement.style.display = "block"}</script><script>if(self != top) {top.location = self.location}</script></head>
<body>
<h1><a href=".">WFLP 2016</a> Talk Schedule and Pre-Proceedings</h1>
<style>
  .time {text-decoration: underline; font-weight: bold}
</style>
<style>
  .break {font-weight: bold; border-top: solid black 1px; padding: 4pt}
</style>
<style>
  .abstract {border-left: solid black 1px; border-right: solid black 1px; padding: 4pt}
</style>
<style>
  .abstract:last-child {border-bottom: solid black 1px; padding: 4pt}
</style>
<style>
  .paper {border-left: solid black 1px; border-right: solid black 1px; border-top: solid black 1px; padding: 2pt}
</style>
<style>
  .paper:last-child {border-bottom: solid black 1px; padding: 2pt}
</style>
<style>
  .session {border-left: solid black 1px; border-right: solid black 1px; border-top: solid black 1px; padding: 2pt}
</style>
<style>
  .session:last-child {border-bottom: solid black 1px; padding: 2pt}
</style>
<h2>Invited Talk</h2>
<div>
<div class="paper" id="0">
  <div class="time">Tuesday, 10:20&ndash;11:20</div>
  <span class="title"><b>Declarative Model Transformations with Triple Graph Grammars</b> (<a href="slides/DeclarativeMTWithTGGs.pdf">slides</a>)</span>
  <br/>
  <span class="authors">
    <a href="http://is.uni-paderborn.de/index.php?id=14962">Anthony Anjorin</a>
  </span>
  <br/>
  <b>Abstract:</b><br/>
  Triple Graph Grammars (TGGs) provide a rule-based means of
  specifying a consistency relation over two graph languages. TGG
  rules are declarative in the sense that they are both direction
  agnostic and pattern based, characterising all consistent pairs of
  graphs without fixing the order in which rules are to be applied to
  restore consistency.<br/>
  A declarative specification of consistency is advantageous as very
  different tools can be derived automatically from a TGG including an
  instance generator, consistent forward and backward transformations,
  and incrementally working synchronisers, which are able to realise
  forward and backward change propagation without incurring
  unnecessary information loss.<br/>
  This talk will present TGGs as a pragmatic implementation of the
  more abstract symmetric delta lens framework for bidirectional
  (model) transformations (bx), touching on the main strengths,
  limitations, and future challenges of the approach in comparison to
  other bx languages.
</div>
</div>
<h2>Contributed Papers</h2>
<p>
  The electronic versions of accepted submissions below constitute the informal pre-proceedings of WFLP 2016.
  Formal post-proceedings will be published later in <a href="http://www.eptcs.org/">EPTCS</a>, jointly with <a href="http://www.imn.htwk-leipzig.de/~schwarz/wlp16/program.html">WLP 2016</a>.
</p>
<div class="session">
  <div class="title">Session 1</div>
  <div class="authors">chair: Baltasar Trancón y Widemann</div>
</div>
<div class="paper" id="1">
  <div class="time">Tuesday, 11:40&ndash;12:10</div>
  <span class="title"><b>A Typeful Integration of SQL into Curry</b> (<a href="pre-proceedings/wflp2016_pre-proceedings_paper_01.pdf">paper</a>, <a href="slides/wflp16_slides.pdf">slides</a>)</span>
  <br/>
  <span class="authors">
    <span><a href="http://www.informatik.uni-kiel.de/~mh/">Michael Hanus</a> and Julia Krone</span>
  </span>
  <br/>
  <b>Abstract:</b><br/>
  We present an extension of the declarative programming language
  Curry to support the access to data stored in relational databases
  via SQL. Since Curry is statically typed, our emphasis on this SQL
  integration is on type safety. Our extension respects the type
  system of Curry so that run-time errors due to ill-typed data are
  avoided. This is obtained by preprocessing SQL statements at compile
  time and translating them into type-safe database access
  operations. As a consequence, the type checker of the Curry system
  can spot type errors in SQL statements at compile time. To generate
  appropriately typed access operations, the preprocessor uses an
  entity-relationship (ER) model describing the structure of the
  relational data. In addition to standard SQL, SQL statements
  embedded in Curry can include program expressions and also
  relationships specified in the ER model. The latter feature is
  useful to avoid the error-prone use of foreign keys. As a result,
  our SQL integration supports a high-level and type-safe access to
  databases in Curry programs.
</div>
<div class="paper" id="3">
  <div class="time">Tuesday, 12:10&ndash;12:40</div>
  <span class="title"><b>A simulation tool for <i>tccp</i> programs</b> (<a href="pre-proceedings/wflp2016_pre-proceedings_paper_03.pdf">paper</a>, <a href="slides/WFLP2016_slides.pdf">slides</a>)</span>
  <br/>
  <span class="authors"><span>
      <a href="http://www.morse.uma.es/user/18">María-del-Mar Gallardo</a>, <a href="http://morse.uma.es/user/7">Leticia Lavado</a> and <a href="http://www.morse.uma.es/user/20">Laura Panizo</a></span>
  </span>
  <br/>
  <b>Abstract:</b><br/>
  The Timed Concurrent Constraint Language <i>tccp</i> is a
  declarative synchronous concurrent language, particularly suitable
  for modelling reactive systems. In <i>tccp</i>, agents communicate
  and synchronise through a global constraint store. It supports a
  notion of discrete time that allows all non-blocked agents to
  proceed with their execution simultaneously.<br/>
  In this paper, we present a modular architecture for the simulation
  of <i>tccp</i> programs. The tool comprises three main
  components. First, a set of basic abstract instructions able to
  model the <i>tccp</i> agent behaviour, the memory model needed to
  manage the active agents and the state of the store during the
  execution. Second, the agent interpreter that executes the
  instructions of the current agent iteratively and calculates the new
  agents to be executed at the next time instant. Finally, the
  constraint solver components which are the modules that deal with
  constraints.<br/>
  In this paper, we describe the implementation of these components
  and present an example of a real system modelled in <i>tccp</i>.
</div>
<div class="break">Lunch</div>
<div class="session">
  <div class="title">Session 2</div>
  <div class="authors">chair: Michael Hanus</div>
</div>
<div class="paper" id="6">
  <div class="time">Tuesday, 14:00&ndash;14:30</div>
  <span class="title"><b>Selene: A Generic Framework for Model Checking Concurrent Programs from Their Semantics in Maude</b> (<a href="pre-proceedings/wflp2016_pre-proceedings_paper_06.pdf">paper</a>, <a href="slides/WFLP16-Selene.pdf">slides</a>)</span>
  <br/>
  <span class="authors">
    <span><a href="http://maude.sip.ucm.es/~adrian/">Adrián Riesco</a> and Gorka Suárez-García</span>
  </span>
  <br/>
  <b>Abstract:</b><br/>
  Model checking is an automatic technique for verifying whether some
  properties hold in a concurrent system. Maude is a high-performance
  logical framework where other systems can be easily specified,
  executed, and analyzed. Moreover, Maude includes a model checker for
  checking properties expressed in Linear Temporal Logic. However,
  when a property on a program written in a programming language
  specified in Maude does not hold the counterexample generated by
  this system refers to the Maude semantics, which can be difficult to
  follow.<br/>
  In this paper we present Selene, a generic framework for dealing
  with asynchronous concurrent systems that allows users to manipulate
  the counterexample generated by the Maude model checker to relate it
  to the program being analyzed. This is achieved by providing a
  kernel for dealing with messages and memory, which are later handled
  in the counterexample; the user can specify the details of his
  semantics on top of this kernel.
</div>
<div class="paper" id="12">
  <div class="time">Tuesday, 14:30&ndash;15:00</div>
  <span class="title"><b>A Framework for Extending microKanren with Constraints</b> (<a href="pre-proceedings/wflp2016_pre-proceedings_paper_12.pdf">paper</a>, <a href="slides/constraint-microKanren.key">slides</a>)</span>
  <br/>
  <span class="authors">
    <span><a href="http://hemann.pl">Jason Hemann</a> and <a href="https://www.cs.indiana.edu/~dfried/">Daniel P. Friedman</a></span>
  </span>
  <br/>
  <b>Abstract:</b><br/>
  We present a framework for building CLP languages with symbolic
  constraints based on microKanren, a domain-specific logic language
  shallowly embedded in Racket. A language designer provides the names
  and violation conditions of atomic constraints. We rely on Racket's
  macro system to generate a black-box constraint solver and other
  components of the microKanren embedding. The framework itself and
  the implementation of common Kanren constraints amounts to just over
  100 lines of code. Our framework is both a teachable implementation
  for constraint logic programming as well as a test-bed and
  prototyping tool for constraint systems.
</div>
<div class="paper" id="5">
  <div class="time">Tuesday, 15:00&ndash;15:30</div>
  <span class="title"><b>Using Haskell for a Declarative Implementation of System Z Inference</b> (<a href="pre-proceedings/wflp2016_pre-proceedings_paper_05.pdf">paper</a>)</span>
  <br/>
  <span class="authors">
    <span>Steven Kutsch and <a href="http://www.fernuni-hagen.de/pi8">Christoph Beierle</a></span>
  </span>
  <br/>
  <b>Abstract:</b><br/>
  Qualitative conditionals of the form "if A then usually B" are a
  powerful means in knowledge representation, establishing a plausible
  relationship between A and B. When reasoning based on conditional
  knowledge consisting of a set of conditionals, a rich structure
  going beyond classical logic is required, e.g. ranking functions
  that assign a degree of implausibility to each possible
  world. System Z is a popular approach, using a unique partitioning
  of the knowledge base to generate the Pareto-minimal ranking
  function. This ranking function is used to answer questions
  plausibly based on the conditionals in the knowledge base. In this
  paper, we describe a Haskell implementation of system Z. To keep the
  Haskell code as close as possible to the formal definition of System
  Z, we make extensive use of language features such as list
  comprehension and higher order functions. For example, these are
  used to generate the required partition of the knowledge base or to
  represent the induced ranking function. The described system is used
  as a backend in the conditional reasoning tool InfOCF.
</div>
<div class="break">Excursion and Dinner</div>
<div class="session">
  <div class="title">Session 3</div>
  <div class="authors">chair: Sebastiaan Joosten</div>
</div>
<div class="paper" id="4">
  <div class="time">Wednesday, 09:00&ndash;09:30</div>
  <span class="title"><b>A Practical Study of Control in Objected-Oriented--Functional--Logic Programming with Paisley</b> (<a href="pre-proceedings/wflp2016_pre-proceedings_paper_04.pdf">paper</a>, <a href="slides/wflp2016-slides.pdf">slides</a>)</span>
  <br/>
  <span class="authors">
    <span><a href="http://www.tu-ilmenau.de/psc/">Baltasar Trancón y Widemann</a> and <a href="http://markuslepper.eu">Markus Lepper</a></span>
  </span>
  <br/>
  <b>Abstract:</b><br/>
  Paisley is an extensible lightweight embedded domain-specific
  language for nondeterministic pattern matching in Java. Using simple
  APIs and programming idioms, it brings the power of functional-logic
  processing of arbitrary data objects to the Java platform, without
  constraining the underlying object-oriented semantics. Here we
  present an extension to the Paisley framework that adds
  pattern-based control flow. It exploits recent additions to the Java
  language, namely functional interfaces and lambda expressions, for
  an explicit and transparent continuation-passing style approach to
  control. We evaluate the practical impact of the novel features on a
  real-world case study that reengineers a third-party open-source
  project to use Paisley in place of conventional object-oriented data
  query idioms. We find the approach viable for incremental
  refactoring of legacy code, with significant qualitative
  improvements regarding separation of concerns, clarity and
  intentionality, thus making for easier code understanding, testing
  and debugging.
</div>
<div class="paper" id="11">
  <div class="time">Wednesday, 09:30&ndash;10:00</div>
  <span class="title"><b>An Agglomeration Law for Sorting Networks and its Application in Functional Programming</b> (<a href="pre-proceedings/wflp2016_pre-proceedings_paper_11.pdf">paper</a>)</span>
  <br/>
  <span class="authors">
    Lukas Immanuel Schiller
  </span>
  <br/>
  <b>Abstract:</b><br/>
  In this paper we will present a general agglomeration law for
  sorting networks. Agglomeration is a common technique when designing
  parallel programs to control the granularity of the computation and
  thereby finding a better fit between the algorithm and the machine
  on which the algorithm runs. Usually this is done by grouping
  smaller tasks and computing them en bloc within one parallel
  process. In the case of sorting networks this could be done by
  computing bigger parts of the networks with one process. The
  agglomeration law in this paper pursues a different strategy: The
  input data is grouped and the algorithm is generalized to work on
  the agglomerated input while the original structure of the algorithm
  remains. This will result in a new access opportunity to sorting
  networks well suited for efficient parallelization on modern
  multicore computers, computer networks or GPGPU
  programming. Additionally this enables us to use sorting networks as
  (parallel or distributed) merging stages for arbitrary sorting
  algorithms and thereby combining new hybrid sorting algorithms with
  ease. The expressiveness of functional programming languages helps
  us to apply this law to systematically constructed sorting networks
  leading to efficient and easily adaptable sorting algorithms. An
  application example is given, using the Eden programming language to
  show the effectiveness of this law.
</div>
<div class="paper" id="9">
  <div class="time">Wednesday, 10:00&ndash;10:30</div>
  <span class="title"><b>Proving Non-Deterministic Computations in Agda</b> (<a href="pre-proceedings/wflp2016_pre-proceedings_paper_09.pdf">paper</a>)</span>
  <br/>
  <span class="authors">
    <span><a href="http://www.cs.pdx.edu/~antoy/">Sergio Antoy</a>, <a href="http://www.informatik.uni-kiel.de/~mh/">Michael Hanus</a> and Steven Libby</span>
  </span>
  <br/>
  <b>Abstract:</b><br/>
  We investigate proving properties of Curry programs using
  Agda. First, we address the functional correctness of Curry
  functions that, apart from some syntactic and semantic differences,
  are in the intersection of the two languages. Second, we use Agda to
  model non-deterministic functions with two distinct and competitive
  approaches incorporating the non-determinism. The first approach
  eliminates non-determinism by considering the set of all
  non-deterministic values produced by an application. The second
  approach encodes every non-deterministic choice that the application
  could perform. We consider our initial experiment a
  success. Although proving properties of programs is a notoriously
  difficult task, the functional logic paradigm does not seem to add
  any significant layer of difficulty or complexity to the task.
</div>
<!--
<div class="paper" id="10">
  <span class="title"><b>Extending Curry with Arrays</b></span>
  <br/>
  <span class="authors">
    <span>José María Rey Poza and Julio Mariño</span>
  </span>
  <br/>
  <b>Abstract:</b><br/>
  Arrays are very common artifacts of imperative programming: they
  provide a highly structured space to store information, their
  management is straightforward and, above all, any of their positions
  can be accessed in a short, constant time.<br/>
  However, none of the proposals for their inclusion into functional
  and logic programming has gained mainstream attention, maybe because
  arrays are naturally related to iterative control, which is missing
  in most declarative languages and because of the close association
  between arrays and destructive assignment. Without destructive
  assignment, arrays are reduced to read-only structures, which limits
  their power. We present a proposal to extend the functional logic
  language Curry with arrays in a natural manner.<br/>
  We propose two types of arrays: easy-to-use logic variable arrays
  with limited assignment capabilities and, also, more complex monadic
  arrays that provide full destructive assignment. Each type presents
  a balance between usability and power while maintaining
  declarativeness at all times. It is up to the programmer to choose
  the type that best suits his/her needs. We have implemented both
  array types in our Curry compiler (Sloth). This work includes a
  description of that implementation.
</div>
-->
<div class="break">Break, then <a href="http://hal2016.haskell.org/#program">HaL 2016</a> begins</div>
</body>
</html>
